/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.  Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: http://www.gnu.org/copyleft/fdl.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
    \page deployment.html
    \title Deploying Qt Applications

    Deploying an Qt application does not require any C++
    programming. All you need to do is to build Qt and your
    application in release mode, following the procedures described in
    this documentation. We will demonstrate the procedures in terms of
    deploying the \l {tools/plugandpaint}{Plug & Paint} application
    that is provided in Qt's examples directory.

    \section1 Static vs. Shared Libraries

    There are two ways of deploying an application:

    \list
        \li Static Linking
        \li Shared Libraries (Frameworks on Mac)
    \endlist

    Static linking results in a stand-alone executable. The advantage
    is that you will only have a few files to deploy. The
    disadvantages are that the executables are large and with no
    flexibility (i.e a new version of the application, or of Qt, will
    require that the deployment process is repeated), and that you
    cannot deploy plugins.

    To deploy plugin-based applications, you can use the shared
    library approach. Shared libraries also provide smaller, more
    flexible executables. For example, using the shared library
    approach, the user is able to independently upgrade the Qt library
    used by the application.

    Another reason why you might want to use the shared library
    approach, is if you want to use the same Qt libraries for a family
    of applications. In fact, if you download the binary installation
    of Qt, you get Qt as a shared library.

    The disadvantage with the shared library approach is that you
    will get more files to deploy. For more information, see
    \l{Creating Shared Libraries}.

    \section1 Deploying Qt's Libraries

    \table
    \header
        \li {4,1} Qt Libraries
    \row
        \li \l{Qt Core}{QtCore}
        \li \l{Qt Network}{QtNetwork}
        \li \l{Qt GUI}{QtGui}
        \li \l{Qt SQL}{QtSql}
    \row
        \li \l{Qt Test}{QtTest}
        \li \l{Qt Widgets}{QtWidgets}
        \li \l{Qt QML}{QtQml}
        \li \l{Qt Quick}{QtQuick}
    \row
        \li \l{Qt Multimedia}{QtMultimedia}
        \li \l{Qt WebKit}{QtWebkit}
        \li \l{Qt WebKit Widgets}{QtWebKitWidgets}
        \li \l{Qt XML}{QtXml}
    \row
        \li \l{Qt XML Patterns}{QtXmlPatterns}
        \li \l{Qt SVG}{QtSvg}
        \li \l{Qt Concurrent}{QtConcurrent}
        \li \l{Qt Print Support}{QtPrintSupport}
    \row
        \li \l{Qt D-Bus}{QtDBus}
        \li \l{Qt OpenGL}{QtOpenGL}
        \li \l{ActiveQt}{QtActiveQt}
        \li \l{Qt Graphical Effects}{QtGraphicalEffects}
    \row
        \li \l{Qt Script}{QtScript}
        \li \l{Qt Quick 1}{QtDeclarative}
        \li \l{Qt Image Formats}{QtImageFormats}
    \endtable

    Qt is not a system library, so it must be redistributed with your
    application. The minimum is to redistribute the run-time
    of the libraries used by the application.  However, with static linking,
    the Qt run-times can be compiled into the executable.

    In general, you should deploy all plugins that your Qt build uses,
    excluding those that you have identified as unnecessary for your
    application and its users.

    For instance, you may need to deploy plugins for JPEG support and
    SQL drivers, but you should also deploy plugins that your users may
    require, including those for accessibility.
    For more information about plugins, see \l{How to Create Qt Plugins}.

    While deploying an application using the shared library approach,
    you must ensure that the Qt libraries use the correct path to
    find the Qt plugins, documentation, translation, and so on. To do this, you
    can use a \c qt.conf file. For more information, see \l {Using
    qt.conf}.

    Depending on configuration, compiler-specific libraries must be
    redistributed as well. For more information, see the
    platform-specific application dependencies for
    \l{deployment-x11.html#application-dependencies}{X11},
    \l{deployment-windows.html#application-dependencies}{Windows},
    and \l{deployment-mac.html#application-dependencies}{Mac}.

    \section1 Licensing

    Some of Qt's libraries are based on third party libraries that are
    not licensed using the same dual-license model as Qt. As a result,
    care must be taken when deploying applications that use these
    libraries, particularly when the application is statically linked
    to them.

    The following table summarizes a few issues that
    you should be aware of.

    \table
    \header \li Qt Library \li Dependency
            \li Licensing Issue
    \row    \li \l{QtHelp}     \li CLucene
    \li The version of clucene distributed with Qt is licensed
    under the GNU LGPL version 2.1 or later. This has implications for
    developers of closed source applications. Please see
    \l{QtHelp Module#License Information}{the QtHelp module documentation}
    for more information.

    \row    \li \l{QtNetwork}  \li OpenSSL
    \li Some configurations of QtNetwork use OpenSSL at run-time. Deployment
    of OpenSSL libraries is subject to both licensing and export restrictions.
    More information can be found in the \l{Secure Sockets Layer (SSL) Classes}
    documentation.

    \row    \li \l{QtWebKit}   \li WebKit
    \li WebKit is licensed under the GNU LGPL version 2 or later.
    This has implications for developers of closed source applications.
    Please see \l{WebKit in Qt#License Information}{the QtWebKit module
    documentation} for more information.

    \endtable

    \section1 Platform-Specific Notes

    The procedure of deploying Qt applications is different for the
    various platforms:

    \list
        \li \l{Deploying an Application on X11 Platforms}{Qt for X11 Platforms}
        \li \l{Deploying an Application on Windows}{Qt for Windows}
        \li \l{Deploying an Application on Mac OS X}{Qt for Mac OS X}
    \endlist

    \sa Installation
*/

/*!
    \page deployment-x11.html
    \contentspage Deploying Qt Applications

    \title Deploying an Application on X11 Platforms

    Due to the proliferation of Unix systems (commercial Unices, Linux
    distributions, etc.), deployment on Unix is a complex
    topic. Before we start, be aware that programs compiled for one
    Unix flavor will probably not run on a different Unix system. For
    example, unless you use a cross-compiler, you cannot compile your
    application on Irix and distribute it on AIX.

    Contents:

    \tableofcontents

    This documentation will describe how to determine which files you
    should include in your distribution, and how to make sure that the
    application will find them at run-time. We will demonstrate the
    procedures in terms of deploying the \l {tools/plugandpaint}{Plug
    & Paint} application that is provided in Qt's examples directory.

    \section1 Static Linking

    Static linking is often the safest and easiest way to distribute
    an application on Unix since it relieves you from the task of
    distributing the Qt libraries and ensuring that they are located
    in the default search path for libraries on the target system.

    \section2 Building Qt Statically

    To use this approach, you must start by installing a static version
    of the Qt library:

    \snippet snippets/code/doc_src_deployment.qdoc 0

    We specify the prefix so that we do not overwrite the existing Qt
    installation. The example above only builds the Qt libraries,
    i.e. the examples and Qt Designer will not be built.  When \c make
    is done, you will find the Qt libraries in the \c /path/to/Qt/lib
    directory.

    When linking your application against static Qt libraries, note
    that you might need to add more libraries to the \c LIBS line in
    your project file. For more information, see the \l {Application
    Dependencies} section.

    \section2 Linking the Application to the Static Version of Qt

    Once Qt is built statically, the next step is to regenerate the
    makefile and rebuild the application. First, we must go into the
    directory that contains the application:

    \snippet snippets/code/doc_src_deployment.qdoc 1

    Now run qmake to create a new makefile for the application, and do
    a clean build to create the statically linked executable:

    \snippet snippets/code/doc_src_deployment.qdoc 2

    You probably want to link against the release libraries, and you
    can specify this when invoking \c qmake. Note that we must set the
    path to the static Qt that we just built.

    To check that the application really links statically with Qt, run
    the \c ldd tool (available on most Unices):

    \snippet snippets/code/doc_src_deployment.qdoc 3

    Verify that the Qt libraries are not mentioned in the output.

    Now, provided that everything compiled and linked without any
    errors, we should have a \c plugandpaint file that is ready for
    deployment. One easy way to check that the application really can
    be run stand-alone is to copy it to a machine that doesn't have Qt
    or any Qt applications installed, and run it on that machine.

    Remember that if your application depends on compiler specific
    libraries, these must still be redistributed along with your
    application. For more information, see the \l {Application
    Dependencies} section.

    The \l {tools/plugandpaint}{Plug & Paint} example consists of
    several components: The core application (\l
    {tools/plugandpaint}{Plug & Paint}), and the \l
    {tools/plugandpaintplugins/basictools}{Basic Tools} and \l
    {tools/plugandpaintplugins/extrafilters}{Extra Filters}
    plugins. Since we cannot deploy plugins using the static linking
    approach, the executable we have prepared so far is
    incomplete. The application will run, but the functionality will
    be disabled due to the missing plugins. To deploy plugin-based
    applications we should use the shared library approach.

    \section1 Shared Libraries

    We have two challenges when deploying the \l
    {tools/plugandpaint}{Plug & Paint} application using the shared
    libraries approach: The Qt runtime has to be correctly
    redistributed along with the application executable, and the
    plugins have to be installed in the correct location on the target
    system so that the application can find them.

    \section2 Building Qt as a Shared Library

    We assume that you already have installed Qt as a shared library,
    which is the default when installing Qt, in the \c /path/to/Qt
    directory. For more information on how to build Qt, see the \l
    {Installation} documentation.

    \section2 Linking the Application to Qt as a Shared Library

    After ensuring that Qt is built as a shared library, we can build
    the \l {tools/plugandpaint}{Plug & Paint} application. First, we
    must go into the directory that contains the application:

    \snippet snippets/code/doc_src_deployment.qdoc 4

    Now run qmake to create a new makefile for the application, and do
    a clean build to create the dynamically linked executable:

    \snippet snippets/code/doc_src_deployment.qdoc 5

    This builds the core application, the following will build the
    plugins:

    \snippet snippets/code/doc_src_deployment.qdoc 6

    If everything compiled and linked without any errors, we will get
    a \c plugandpaint executable and the \c libpnp_basictools.so and
    \c libpnp_extrafilters.so plugin files.

    \section2 Creating the Application Package

    There is no standard package management on Unix, so the method we
    present below is a generic solution. See the documentation for
    your target system for information on how to create a package.

    To deploy the application, we must make sure that we copy the
    relevant Qt libraries (corresponding to the Qt modules used in the
    application) as well as the executable to the same
    directory. Remember that if your application depends on compiler
    specific libraries, these must also be redistributed along with
    your application. For more information, see the \l {Application
    Dependencies} section.

    We'll cover the plugins shortly, but the main issue with shared
    libraries is that you must ensure that the dynamic linker will
    find the Qt libraries. Unless told otherwise, the dynamic linker
    doesn't search the directory where your application resides. There
    are many ways to solve this:

    \list

    \li You can install the Qt libraries in one of the system
       library paths (e.g. \c /usr/lib on most systems).

    \li You can pass a predetermined path to the \c -rpath command-line
       option when linking the application. This will tell the dynamic
       linker to look in this directory when starting your application.

    \li You can write a startup script for your application, where you
       modify the dynamic linker configuration (e.g., adding your
       application's directory to the \c LD_LIBRARY_PATH environment
       variable. \note If your application will be running with "Set
       user ID on execution," and if it will be owned by root, then
       LD_LIBRARY_PATH will be ignored on some platforms. In this
       case, use of the LD_LIBRARY_PATH approach is not an option).

    \endlist

    The disadvantage of the first approach is that the user must have
    super user privileges. The disadvantage of the second approach is
    that the user may not have privileges to install into the
    predetermined path. In either case, the users don't have the option
    of installing to their home directory. We recommend using the
    third approach since it is the most flexible. For example, a \c
    plugandpaint.sh script will look like this:

    \snippet snippets/code/doc_src_deployment.qdoc 7

    By running this script instead of the executable, you are sure
    that the Qt libraries will be found by the dynamic linker. Note
    that you only have to rename the script to use it with other
    applications.

    When looking for plugins, the application searches in a plugins
    subdirectory inside the directory of the application
    executable. Either you have to manually copy the plugins into the
    \c plugins directory, or you can set the \c DESTDIR in the
    plugins' project files:

    \snippet snippets/code/doc_src_deployment.pro 8

    An archive distributing all the Qt libraries, and all the plugins,
    required to run the \l {tools/plugandpaint}{Plug & Paint}
    application, would have to include the following files:

    \table 100%
    \header
        \li Component \li {2, 1} File Name
    \row
        \li The executable
        \li {2, 1} \c plugandpaint
    \row
        \li The script to run the executable
        \li {2, 1} \c plugandpaint.sh
    \row
        \li The Basic Tools plugin
        \li {2, 1} \c plugins\libpnp_basictools.so
    \row
        \li The ExtraFilters plugin
        \li {2, 1} \c plugins\libpnp_extrafilters.so
    \row
        \li The Qt xcb platform plugin
        \li {2, 1} \c platforms\libqxcb.so
    \row
        \li The Qt Core module
        \li {2, 1} \c libQt5Core.so.5
    \row
        \li The Qt GUI module
        \li {2, 1} \c libQt5Gui.so.5
    \row
        \li The Qt Widgets module
        \li {2, 1} \c libQt5Widgets.so.5
    \endtable

    On most systems, the extension for shared libraries is \c .so. A
    notable exception is HP-UX, which uses \c .sl.

    Remember that if your application depends on compiler specific
    libraries, these must still be redistributed along with your
    application. For more information, see the \l {Application
    Dependencies} section.

    To verify that the application now can be successfully deployed,
    you can extract this archive on a machine without Qt and without
    any compiler installed, and try to run it, i.e. run the \c
    plugandpaint.sh script.

    An alternative to putting the plugins in the \c plugins
    subdirectory is to add a custom search path when you start your
    application using QApplication::addLibraryPath() or
    QApplication::setLibraryPaths().

    \snippet snippets/code/doc_src_deployment.cpp 9

    \section1 Application Dependencies

    \section2 Additional Libraries

    To find out which libraries your application depends on, run the
    \c ldd tool (available on most Unices):

    \snippet snippets/code/doc_src_deployment.qdoc 10

    This will list all the shared library dependencies for your
    application. Depending on configuration, these libraries must be
    redistributed along with your application. In particular, the
    standard C++ library must be redistributed if you're compiling
    your application with a compiler that is binary incompatible with
    the system compiler. When possible, the safest solution is to link
    against these libraries statically.

    You will probably want to link dynamically with the regular X11
    libraries, since some implementations will try to open other
    shared libraries with \c dlopen(), and if this fails, the X11
    library might cause your application to crash.

    It's also worth mentioning that Qt will look for certain X11
    extensions, such as Xinerama and Xrandr, and possibly pull them
    in, including all the libraries that they link against. If you
    can't guarantee the presence of a certain extension, the safest
    approach is to disable it when configuring Qt (e.g. \c {./configure
    -no-xrandr}).

    FontConfig and FreeType are other examples of libraries that
    aren't always available or that aren't always binary
    compatible. As strange as it may sound, some software vendors have
    had success by compiling their software on very old machines and
    have been very careful not to upgrade any of the software running
    on them.

    When linking your application against the static Qt libraries, you
    must explicitly link with the dependent libraries mentioned
    above. Do this by adding them to the \c LIBS variable in your
    project file.

    \section2 Qt Plugins

    Your application may also depend on one or more Qt plugins, such
    as the JPEG image format plugin or a SQL driver plugin. Be sure
    to distribute any Qt plugins that you need with your application,
    and note that each type of plugin should be located within a
    specific subdirectory (such as \c imageformats or \c sqldrivers)
    within your distribution directory, as described below.

    \note If you are deploying an application that uses QtWebKit to display
    HTML pages from the World Wide Web, you should include all text codec
    plugins to support as many HTML encodings possible.

    The search path for Qt plugins (as well as a few other paths) is
    hard-coded into the QtCore library. By default, the first plugin
    search path will be hard-coded as \c /path/to/Qt/plugins. As
    mentioned above, using predetermined paths has certain
    disadvantages, so you need to examine various alternatives to make
    sure that the Qt plugins are found:

    \list

    \li \l{qt-conf.html}{Using \c qt.conf}. This is the recommended
    approach since it provides the most flexibility.

    \li Using QApplication::addLibraryPath() or
    QApplication::setLibraryPaths().

    \li Using a third party installation utility or the target system's
    package manager to change the hard-coded paths in the QtCore
    library.

    \endlist

    The \l{How to Create Qt Plugins} document outlines the issues you
    need to pay attention to when building and deploying plugins for
    Qt applications.
*/

/*!
    \page deployment-windows.html
    \contentspage Deploying Qt Applications

    \title Deploying an Application on Windows

    This documentation will describe how to determine which files you
    should include in your distribution, and how to make sure that the
    application will find them at run-time. We will demonstrate the
    procedures in terms of deploying the \l {tools/plugandpaint}{Plug
    & Paint} application that is provided in Qt's examples directory.

    Contents:

    \tableofcontents

    \section1 Static Linking

    If you want to keep things simple by only having a few files to
    deploy, i.e. a stand-alone executable with the associated compiler
    specific DLLs, then you must build everything statically.

    \section2 Building Qt Statically

    Before we can build our application we must make sure that Qt is
    built statically. To do this, go to a command prompt and type the
    following:

    \snippet snippets/code/doc_src_deployment.qdoc 11

    Remember to specify any other options you need, such as data base
    drivers, as arguments to \c configure. Once \c configure has
    finished, type the following:

    \snippet snippets/code/doc_src_deployment.qdoc 12

    This will build Qt statically. Note that we have used \c nmake
    in all the examples, but \c mingw32-make should be used for MinGW.

    \note If you later need to reconfigure and rebuild Qt from the
    same location, ensure that all traces of the previous configuration are
    removed by entering the build directory and typing \c{nmake distclean}
    before running \c configure again.

    \section2 Linking the Application to the Static Version of Qt

    Once Qt has finished building we can build the \l
    {tools/plugandpaint}{Plug & Paint} application. First we must go
    into the directory that contains the application:

    \snippet snippets/code/doc_src_deployment.qdoc 13

    We must then run \c qmake to create a new makefile for the
    application, and do a clean build to create the statically linked
    executable:

    \snippet snippets/code/doc_src_deployment.qdoc 14

    You probably want to link against the release libraries, and you
    can specify this when invoking \c qmake. Now, provided that
    everything compiled and linked without any errors, we should have
    a \c plugandpaint.exe file that is ready for deployment. One easy
    way to check that the application really can be run stand-alone is
    to copy it to a machine that doesn't have Qt or any Qt
    applications installed, and run it on that machine.

    Remember that if your application depends on compiler specific
    libraries, these must still be redistributed along with your
    application. You can check which libraries your application is
    linking against by using the \c depends tool. For more
    information, see the \l {Application Dependencies} section.

    The \l {tools/plugandpaint}{Plug & Paint} example consists of
    several components: The application itself (\l
    {tools/plugandpaint}{Plug & Paint}), and the \l
    {tools/plugandpaintplugins/basictools}{Basic Tools} and \l
    {tools/plugandpaintplugins/extrafilters}{Extra Filters}
    plugins. Since we cannot deploy plugins using the static linking
    approach, the application we have prepared is incomplete. It will
    run, but the functionality will be disabled due to the missing
    plugins. To deploy plugin-based applications we should use the
    shared library approach.

    \section1 Shared Libraries

    We have two challenges when deploying the \l
    {tools/plugandpaint}{Plug & Paint} application using the shared
    libraries approach: The Qt runtime has to be correctly
    redistributed along with the application executable, and the
    plugins have to be installed in the correct location on the target
    system so that the application can find them.

    \section2 Building Qt as a Shared Library

    We assume that you already have installed Qt as a shared library,
    which is the default when installing Qt, in the \c C:\path\to\Qt
    directory. For more information on how to build Qt, see the \l
    {Installation} documentation.

    \section2 Linking the Application to Qt as a Shared Library

    After ensuring that Qt is built as a shared library, we can build
    the \l {tools/plugandpaint}{Plug & Paint} application. First, we
    must go into the directory that contains the application:

    \snippet snippets/code/doc_src_deployment.qdoc 15

    Now run \c qmake to create a new makefile for the application, and
    do a clean build to create the dynamically linked executable:

    \snippet snippets/code/doc_src_deployment.qdoc 16

    This builds the core application, the following will build the
    plugins:

    \snippet snippets/code/doc_src_deployment.qdoc 17

    If everything compiled and linked without any errors, we will get
    a \c plugandpaint.exe executable and the \c pnp_basictools.dll and
    \c pnp_extrafilters.dll plugin files.

    \section2 Creating the Application Package

    To deploy the application, we must make sure that we copy the
    relevant Qt DLL (corresponding to the Qt modules used in
    the application) and the windows platform plugin as well as the executable
    to the same directory in the \c release subdirectory.

    In contrast to user plugins, Qt plugins have to be put into subdirectories
    matching the plugin type. As we want to deploy the windows platform plugin
    it has to be put into a "platforms" subdirectory. Additional information
    about user and Qt plugins will be covered later.

    Qt relies on the \l{ICU} library for unicode support. Therefore, you must
    include the ICU DLLs that are located in the \c bin directory of your Qt
    installation if Qt was configured to use ICU. The Qt version bundled in
    the Qt5 package uses ICU, so deployment is needed there. The ICU DLLs are
    version dependent and have to match the ones your Qt version was linked
    against.

    If you are using \l{ANGLE} (the default) then you additionally
    need to include both libEGL.dll and libGLESv2.dll from Qt's 'lib'
    directory as well as the HLSL compiler from DirectX. The HLSL
    compiler library is called d3dcompiler_XX.dll where XX is the
    version number that ANGLE (libGLESv2) was linked against.

    Remember that if your application depends on compiler specific
    libraries, these must be redistributed along with your
    application. You can check which libraries your application is
    linking against by using the \c depends tool. For more
    information, see the \l {Application Dependencies} section.

    We'll cover the plugins shortly, but first we'll check that the
    application will work in a deployed environment: Either copy the
    executable and the Qt DLLs to a machine that doesn't have Qt
    or any Qt applications installed, or if you want to test on the
    build machine, ensure that the machine doesn't have Qt in its
    environment.

    If the application starts without any problems, then we have
    successfully made a dynamically linked version of the \l
    {tools/plugandpaint}{Plug & Paint} application. But the
    application's functionality will still be missing since we have
    not yet deployed the associated plugins.

    Plugins work differently to normal DLLs, so we can't just
    copy them into the same directory as our application's executable
    as we did with the Qt DLLs.  When looking for plugins, the
    application searches in a \c plugins subdirectory inside the
    directory of the application executable.

    So to make the plugins available to our application, we have to
    create the \c plugins subdirectory and copy over the relevant DLLs:

    \snippet snippets/code/doc_src_deployment.qdoc 18

    An archive distributing all the Qt DLLs and application
    specific plugins required to run the \l {tools/plugandpaint}{Plug
    & Paint} application, would have to include the following files:

    \table 100%
    \header
        \li Component \li {2, 1} File Name
    \row
        \li The executable
        \li {2, 1} \c plugandpaint.exe
    \row
        \li The Basic Tools plugin
        \li {2, 1} \c plugins\pnp_basictools.dll
    \row
        \li The ExtraFilters plugin
        \li {2, 1} \c plugins\pnp_extrafilters.dll
    \row
        \li The Qt Windows platform plugin
        \li {2, 1} \c platforms\qwindows.dll
    \row
        \li The Qt Core module
        \li {2, 1} \c Qt5Core.dll
    \row
        \li The Qt GUI module
        \li {2, 1} \c Qt5Gui.dll
    \row
        \li The Qt Widgets module
        \li {2, 1} \c Qt5Widgets.dll
    \endtable

    In addition, the archive must contain the following compiler
    specific libraries depending on your version of Visual Studio:

    \table 100%
    \header
        \li \li VC++ 8.0 (2005) \li VC++ 9.0 (2008) \li VC++ 10.0 (2010)
    \row
        \li The C run-time
        \li \c msvcr80.dll
        \li \c msvcr90.dll
        \li \c msvcr100.dll
    \row
        \li The C++ run-time
        \li \c msvcp80.dll
        \li \c msvcp90.dll
        \li \c msvcp100.dll
    \endtable

    If ICU was used, the archive must contain:

    \table 100%
    \header
        \li{3,1} File Name
    \row
        \li icudtXX.dll
        \li icuinXX.dll
        \li icuucXX.dll
    \endtable

    Finally, if ANGLE was used, then the archive must additionally
    contain:

    \table 100%
    \header
        \li{3,1} File Name
    \row
        \li libEGL.dll
        \li libGLESv2.dll
        \li d3dcompiler_XX.dll
    \endtable

    To verify that the application now can be successfully deployed,
    you can extract this archive on a machine without Qt and without
    any compiler installed, and try to run it.

    An alternative to putting the plugins in the plugins subdirectory
    is to add a custom search path when you start your application
    using QApplication::addLibraryPath() or
    QApplication::setLibraryPaths().

    \snippet snippets/code/doc_src_deployment.cpp 19

    One benefit of using plugins is that they can easily be made
    available to a whole family of applications.

    It's often most convenient to add the path in the application's \c
    main() function, right after the QApplication object is
    created. Once the path is added, the application will search it
    for plugins, in addition to looking in the \c plugins subdirectory
    in the application's own directory. Any number of additional paths
    can be added.

    \section2 Manifest files

    When deploying an application compiled with Visual Studio 2005 onwards,
    there are some additional steps to be taken.

    First, we need to copy the manifest file created when linking the
    application. This manifest file contains information about the
    application's dependencies on side-by-side assemblies, such as the runtime
    libraries.

    The manifest file needs to be copied into the \b same folder as the
    application executable. You do not need to copy the manifest files for
    shared libraries (DLLs), since they are not used.

    If the shared library has dependencies that are different from the
    application using it, the manifest file needs to be embedded into the DLL
    binary. Since Qt 4.1.3, the follwoing \c CONFIG options are available for
    embedding manifests:

    \snippet snippets/code/doc_src_deployment.qdoc 20

    To use the options, add

    \snippet snippets/code/doc_src_deployment.pro 21

    to your .pro file. The \c embed_manifest_dll option is enabled by default.
	The \c embed_manifest_exe option is NOT enabled by default.

    You can find more information about manifest files and side-by-side
    assemblies at the
    \l {http://msdn.microsoft.com/en-us/library/aa376307.aspx}{MSDN website}.

    The correct way to include the runtime libraries with your application
    is to ensure that they are installed on the end-user's system.

    To install the runtime libraries on the end-user's system, you need to
    include the appropriate Visual C++ Redistributable Package (VCRedist)
    executable with your application and ensure that it is executed when the
    user installs your application.

    For example, on an 32-bit x86-based system, you would include the
    \l{http://www.microsoft.com/downloads/details.aspx?FamilyId=32BC1BEE-A3F9-4C13-9C99-220B62A191EE}{vcredist_x86.exe}
    executable. The \l{http://www.microsoft.com/downloads/details.aspx?familyid=526BF4A7-44E6-4A91-B328-A4594ADB70E5}{vcredist_IA64.exe}
    and \l{http://www.microsoft.com/downloads/details.aspx?familyid=90548130-4468-4BBC-9673-D6ACABD5D13B}{vcredist_x64.exe}
    executables provide the appropriate libraries for the IA64 and 64-bit x86
    architectures, respectively.

    \note The application you ship must be compiled with exactly the same
    compiler version against the same C runtime version. This prevents
    deploying errors caused by different versions of the C runtime libraries.

    \section2 Manual installations with Visual Studio 2008 and 2010

    As well as the above details for VS 2005 and onwards, Visual Studio 2008/2010
    applications may have problems when deploying manually, say to a USB
    stick.

    The recommended procedure is to configure Qt with the \c -plugin-manifests
    option using the 'configure' tool. Then follow the \l {http://msdn.microsoft.com/en-us/library/ms235291(VS.80).aspx}{guidelines}
    for manually deploying private assemblies.

    In brief the steps are

    \list 1

        \li create a folder structure on the development computer that will match the target USB stick directory structure, for example '\\app' and for your dlls, '\\app\\lib'.

        \li on the development computer, from the appropriate 'redist' folder copy over Microsoft.VC80.CRT and Microsoft.VC80.MFC to the directories '\\app' and '\\app\\lib' on the development PC.

        \li xcopy the \\app folder to the target USB stick.
    \endlist

    Your application should now run. Also be aware that even with a service
    pack installed the Windows DLLs that are linked to will be the defaults. See
    the information on \l {http://msdn.microsoft.com/en-us/library/cc664727.aspx}{how to select the appropriate target DLLs}.

    \section1 Application Dependencies

    \section2 Additional Libraries

    Depending on configuration, compiler specific libraries must be
    redistributed along with your application.

    For example, if Qt is built using \l{ANGLE}, its shared libraries
    and the required shared libraries of the \l{Direct X SDK} need to
    be shipped as well.

    You can check which
    libraries your application is linking against by using the
    \l{Dependency Walker} tool. All you need to do is to run it like
    this:

    \snippet snippets/code/doc_src_deployment.qdoc 24

    This will provide a list of the libraries that your application
    depends on and other information.

    \image deployment-windows-depends.png

    When looking at the release build of the Plug & Paint executable
    (\c plugandpaint.exe) with the \c depends tool, the tool lists the
    following immediate dependencies to non-system libraries:

    \table 100%
        \header
            \li Qt
            \li VC++ 8.0 (2005)
            \li VC++ 9.0 (2008)
            \li VC++ 10.0 (2010)
            \li MinGW
        \row
        \li \list
               \li QT5CORE.DLL - The QtCore runtime
               \li QT5GUI.DLL - The QtGui runtime
               \li QT5WIDGETS.DLL - The QtWidgets runtime
           \endlist
        \li \list
               \li MSVCR80.DLL - The C runtime
               \li MSVCP80.DLL - The C++ runtime
           \endlist
        \li \list
               \li MSVCR90.DLL - The C runtime
               \li MSVCP90.DLL - The C++ runtime
           \endlist
        \li \list
               \li MSVCR100.DLL - The C runtime
               \li MSVCP100.DLL - The C++ runtime
           \endlist
        \li \list
               \li MINGWM10.DLL - The MinGW run-time
               \li LIBGCC_S_DW2-1.DLL
               \li LIBSTDC++-6.dll
           \endlist
    \endtable

    When looking at the plugin DLLs the exact same dependencies
    are listed.

    \section2 Qt Plugins

    Your application may also depend on one or more Qt plugins, such
    as the print support plugin, the JPEG image format plugin or a SQL driver
    plugin. Be sure to distribute any Qt plugins that you need with your
    application, and note that each type of plugin should be located within a
    specific subdirectory (such as \c printsupport, \c imageformats or
    \c sqldrivers) within your distribution directory, as described below.

    \note If you are deploying an application that uses QtWebKit to display
    HTML pages from the World Wide Web, you should include all text codec
    plugins to support as many HTML encodings possible.

    The search path for Qt plugins is hard-coded into the QtCore library.
    By default, the plugins subdirectory of the Qt installation is the first
    plugin search path. However, pre-determined paths like the default one
    have certain disadvantages. For example, they may not exist on the target
    machine. For that reason, you need to examine various alternatives to make
    sure that the Qt plugins are found:

    \list

    \li \l{qt-conf.html}{Using \c qt.conf}. This approach is the recommended
    if you have executables in different places sharing the same plugins.

    \li Using QApplication::addLibraryPath() or
    QApplication::setLibraryPaths(). This approach is recommended if you only
    have one executable that will use the plugin.

    \li Using a third party installation utility to change the
    hard-coded paths in the QtCore library.

    \endlist

    If you add a custom path using QApplication::addLibraryPath it could
    look like this:

    \snippet snippets/code/doc_src_deployment.qdoc 54

    Then qApp->libraryPaths() would return something like this:

    "C:/customPath/plugins"
    "C:/Qt/5.1.1/plugins"
    "E:/myApplication/directory/"

    The executable will look for the plugins in these directories and
    the same order as the QStringList returned by qApp->libraryPaths().
    The newly added path is prepended to the qApp->libraryPaths() which
    means that it will be searched through first. However, if you use
    qApp->setLibraryPaths(), you will be able to determine which paths
    and in which order they will be searched.

    The \l{How to Create Qt Plugins} document outlines the issues you
    need to pay attention to when building and deploying plugins for
    Qt applications.

    \section1 Related Third Party Resources

    \list
    \li \l{http://silmor.de/29}{Cross compiling Qt/Win Apps on Linux} covers the
    process of cross-compiling Windows applications on Linux.
    \li \l{http://divided-mind.blogspot.com/2007/09/cross-compiling-qt4win-on-linux.html}
    {Cross-compiling Qt4/Win on Linux} provides another Linux-to-Windows
    cross-compilation guide.
    \endlist
*/

/*!
    \page deployment-mac.html
    \contentspage Deploying Qt Applications

    \title Deploying an Application on Mac OS X

    Beginning with Qt 4.5, a \l {macdeploy}{deployment tool} is
    included that automates the procedures described here.

    This document describes how to create a bundle and make sure that the
    application finds the resources it needs at run-time. We demonstrate the
    procedures in terms of deploying the \l {tools/plugandpaint}{Plug & Paint}
    example application that comes with the Qt installation package.

    \tableofcontents

    \section1 The Bundle

    On Mac, a GUI application must be built and run from a bundle, which is a
    directory structure that appears as a single  entity when viewed in the
    Finder. A bundle for an application typically contains the executable and
    all the resources it needs. Here is the snapshot of an application bundle
    structure:

    \image deployment-mac-bundlestructure.png

    The bundle provides many advantages to the user:
    \list
     \li It is easily installable as it is identified as a single entity.
     \li Information about a bundle is accessible from code.
    \endlist
    This is specific to Mac OS X and beyond the scope of this document. For
    more information about bundles, see
    \l {http://developer.apple.com/documentation/CoreFoundation/Conceptual/CFBundles/index.html}{Apple's Developer Website}.

    Add the following statement to your application's project file (\c{.pro}):

    \snippet snippets/code/doc_src_deployment.pro 26

    This tells \c qmake not to put the executable inside a bundle.

    \section1 Static Linking

    If you want to keep things simple and have a few files to
    deploy, you must build your application with statically linked libraries.

    \section2 Building Qt Statically

    Start by installing a static version of the Qt library. Remember that you
    cannot use plugins and that you must build the dependent libraries such
    as image formats, SQL drivers, and so on with static linking.

    \snippet snippets/code/doc_src_deployment.qdoc 27

    You can check the various options that are available by running \c
    configure -help.

    \section2 Linking the Application to the Static Version of Qt

    Once Qt is built statically, the next step is to regenerate the
    makefile and rebuild the application. First, we must go into the
    directory that contains the application:

    \snippet snippets/code/doc_src_deployment.qdoc 28

    Now run \c qmake to create a new makefile for the application, and do
    a clean build to create the statically linked executable:

    \snippet snippets/code/doc_src_deployment.qdoc 29

    You probably want to link against the release libraries, and you
    can specify this when invoking \c qmake. If you have Xcode Tools
    1.5 or higher installed, you may want to take advantage of "dead
    code stripping" to reduce the size of your binary even more. You
    can do this by passing \c {LIBS+= -dead_strip} to \c qmake in
    addition to the \c {-config release} parameter.

    Now, provided that everything compiled and linked without any
    errors, we should have a \c plugandpaint.app bundle ready
    for deployment. Try installing the bundle on a Mac OS x machine that does
    not have Qt or any Qt applications installed.

    You can check what other libraries your application links to using
    the \c otool:

    \snippet snippets/code/doc_src_deployment.qdoc 30

    Here is what the output looks like for the statically linked
    \l {tools/plugandpaint}{Plug & Paint}:

    \snippet snippets/code/doc_src_deployment.qdoc 31

    If you see \e Qt libraries in the output, it probably
    means that you have both dynamic and static Qt libraries installed
    on your machine. The linker always chooses dynamic linking over
    static. If you want to use only static libraries, you can either:
    \list
     \li move your Qt dynamic libraries (\c .dylibs) away to another directory
         while you link the application and then move them back,
     \li or edit the \c Makefile  and replace link lines for the Qt libraries
         with the absolute path to the static libraries.
    \endlist

    For example, replace the following:

    \snippet snippets/code/doc_src_deployment.qdoc 32

    with this:

    \snippet snippets/code/doc_src_deployment.qdoc 33

    The \l {tools/plugandpaint}{Plug & Paint} example consists of
    several components: The core application (\l
    {tools/plugandpaint}{Plug & Paint}), and the \l
    {tools/plugandpaintplugins/basictools}{Basic Tools} and \l
    {tools/plugandpaintplugins/extrafilters}{Extra Filters}
    plugins. As we cannot deploy plugins using the static linking
    approach, the bundle we have prepared so far is incomplete. The
    application will run, but the functionality will be disabled due
    to the missing plugins. To deploy plugin-based applications we
    should use the framework approach, which is specific to Mac OS x.

    \section1 Frameworks

    In this approach, ensure that the Qt runtime is redistributed correctly
    with the application bundle, and that the plugins are installed in the correct
    location so that the application finds them.

    There are two ways to distribute Qt with your application in the frameworks
    approach:
    \list
     \li Private framework within your application bundle.
     \li Standard framework (alternatively use the Qt frameworks in
    the installed binary).
    \endlist

    The former is good if you have Qt built in a special way, or want to make
    sure the framework is there. It just comes down to where you place the Qt
    frameworks.

    The latter option is good if you have many Qt applications and you want
    them use a single Qt framework rather than multiple versions of it.

    \section2 Building Qt as Frameworks

    We assume that you already have installed Qt as frameworks, which
    is the default when installing Qt, in the /path/to/Qt
    directory. For more information on how to build Qt, see the \l
    Installation documentation.

    When installing, the identification name of the frameworks is set. This
    name is used by the dynamic linker (\c dyld) to find the libraries for your
    application.

    \section2 Linking the Application to Qt as Frameworks

    After building Qt as frameworks, we can build the \l
    {tools/plugandpaint}{Plug & Paint} application. First, we must go
    to the directory that contains the application:

    \snippet snippets/code/doc_src_deployment.qdoc 34

    Run \c qmake to create a new makefile for the application, and do
    a clean build to create the dynamically linked executable:

    \snippet snippets/code/doc_src_deployment.qdoc 35

    This builds the core application. Use the following to build the plugins:

    \snippet snippets/code/doc_src_deployment.qdoc 36

    Now run the \c otool for the Qt frameworks, for example Qt Gui:

    \snippet snippets/code/doc_src_deployment.qdoc 37

    You would get the following output:

    \snippet snippets/code/doc_src_deployment.qdoc 38

    For the Qt frameworks, the first line (i.e. \c
    {path/to/Qt/lib/QtGui.framework/Versions/4/QtGui (compatibility
    version 4.0.0, current version 4.0.1)}) becomes the framework's
    identification name which is used by the dynamic linker (\c dyld).

    But when you are deploying the application, your users may not
    have the Qt frameworks installed in the specified location. For
    that reason, you must either provide the frameworks in an agreed
    location, or store the frameworks in the bundle.
    Regardless of which solution you choose, you must make sure that
    the frameworks return the proper identification name for
    themselves, and that the application looks for these names.
    Luckily we can control this with the \c install_name_tool
    command-line tool.

    The \c install_name_tool works in two modes, \c -id and \c
    -change. The \c -id mode is for libraries and frameworks, and
    allows us to specify a new identification name. We use the \c
    -change mode to change the paths in the application.

    Let's test this out by copying the Qt frameworks into the Plug &
    Paint bundle. Looking at \c otool's output for the bundle, we can
    see that we must copy both the QtCore and QtGui frameworks into
    the bundle. We will assume that we are in the directory where we
    built the bundle.

    \snippet snippets/code/doc_src_deployment.qdoc 39

    First we create a \c Frameworks directory inside the bundle. This
    follows the Mac OS X application convention. We then copy the
    frameworks into the new directory. As frameworks contain
    symbolic links, we use the \c -R option.

    \snippet snippets/code/doc_src_deployment.qdoc 40

    Then we run \c install_name_tool to set the identification names
    for the frameworks. The first argument after \c -id is the new
    name, and the second argument is the framework that we want to
    rename.  The text \c @executable_path is a special \c dyld variable
    telling \c dyld to start looking where the executable is located. The new
    names specifies that these frameworks are located in the directory directly
    under the \c Frameworks directory.

    \snippet snippets/code/doc_src_deployment.qdoc 41

    Now, the dynamic linker knows where to look for QtCore and
    QtGui. We must ensure that the application also knows where to find the
    library, using \c install_name_tool's \c -change mode.
    This basically comes down to string replacement, to match the
    identification names that we set earlier to the frameworks.

    Finally, the QtGui framework depends on QtCore, so we must
    remember to change the reference for QtGui:

    \snippet snippets/code/doc_src_deployment.qdoc 42

    After this, we run \c otool again and see that the
    application can find the libraries.

    The plugins for the \l {tools/plugandpaint}{Plug &
    Paint} example makes it interesting. The basic steps we
    need to follow with plugins are:

    \list
        \li put the plugins inside the bundle,
        \li run the \c install_name_tool to check whether the plugins are using
            the correct library,
        \li and ensure that the application knows where to look for the plugins.
    \endlist

    We can put the plugins anywhere we want in the bundle, but the
    best location is to put them under Contents/Plugins. When we built
    the Plug & Paint plugins, based on the \c DESTDIR variable in their \c .pro
    file, the plugins' \c .dylib files are in the \c plugins subdirectory
    under the \c plugandpaint directory. We just have to move this director.

    \snippet snippets/code/doc_src_deployment.qdoc 43

    For example, If we run \c otool on the \l
    {tools/plugandpaintplugins/basictools}{Basic Tools} plugin's \c
    .dylib file, we get the following information.

    \snippet snippets/code/doc_src_deployment.qdoc 44

    Then we can see that the plugin links to the Qt frameworks it was
    built against. As we want the plugins to use the framework in
    the application bundle, we change them the same way as we did for
    the application. For example for the Basic Tools plugin:

    \snippet snippets/code/doc_src_deployment.qdoc 45


    We must also modify the code in \c
    tools/plugandpaint/mainwindow.cpp to \l {QDir::cdUp()}{cdUp()} to ensure
    that the application finds the plugins. Add the following
    code to the \c mainwindow.cpp file:

    \snippet snippets/code/doc_src_deployment.qdoc 46

    \table
    \row
    \li \inlineimage deployment-mac-application.png
    \li
    The additional code in \c tools/plugandpaint/mainwindow.cpp also
    enables us to view the plugins in the Finder, as shown in the image.

    We can also add plugins extending Qt, for example adding SQL
    drivers or image formats. We just need to follow the directory
    structure outlined in plugin documentation, and make sure they are
    included in the QCoreApplication::libraryPaths(). Let's quickly do
    this with the image formats, following the procedure outlined earlier.

    Copy Qt's image format plugins into the bundle:

    \snippet snippets/code/doc_src_deployment.qdoc 47

    Use \c install_name_tool to link the plugins to the frameworks in
    the bundle:

    \snippet snippets/code/doc_src_deployment.qdoc 48

    Update the source code in \c tools/plugandpaint/main.cpp
    to look for the new plugins. After constructing the
    QApplication, we add the following code:

    \snippet snippets/code/doc_src_deployment.cpp 49

    First, we tell the application to only look for plugins in this
    directory. In our case, we want the application to look for only those
    plugins that we distribute with the bundle. If we
    were part of a bigger Qt installation we could have used
    QCoreApplication::addLibraryPath() instead.

    \endtable

    \warning While deploying plugins, we make changes to the
    source code and that resets the default identification names when
    the application is rebuilt. So you must repeat the process of
    making your application link to the correct Qt frameworks in the bundle
    using \c install_name_tool.

    Now you should be able to move the application to another Mac OS X
    machine and run it without Qt installed. Alternatively, you can
    move your frameworks that live outside of the bundle to another
    directory and see if the application still runs.

    If you store the frameworks in another location outside the
    bundle, the technique of linking your application is similar; you
    must make sure that the application and the frameworks agree where
    to be looking for the Qt libraries as well as the plugins.

    \section2 Creating the Application Package

    When you are done linking your application to Qt, either
    statically or as frameworks, the application is ready to be
    distributed. For more information, refer to the
    \l {https://developer.apple.com/library/mac/#documentation/ToolsLanguages/Conceptual/OSXWorkflowGuide/Introduction/Introduction.html}{Tools Workflow Guide}.

    Although the process of deploying an application do have some
    pitfalls, once you know the various issues you can easily create
    packages that all your Mac OS X users will enjoy.

    \section1 Application Dependencies

    \section2 Qt Plugins

    Your application may also depend on one or more Qt plugins, such
    as the JPEG image format plugin or a SQL driver plugin. Be sure
    to distribute any Qt plugins that you need with your application,
    and note that each type of plugin must be located within a
    specific subdirectory (such as \c imageformats or \c sqldrivers)
    in your distribution directory, as described below.

    \note If you are deploying an application that uses QtWebKit to display
    HTML pages from the World Wide Web, you must include all text codec
    plugins to support as many HTML encodings possible.

    The search path for Qt plugins (as well as a few other paths) is
    hard-coded into the QtCore library. By default, the first plugin
    search path will be hard-coded as \c /path/to/Qt/plugins. But
    using pre-determined paths has certain disadvantages. For example,
    they may not exist on the target machine. So you must check
    various alternatives to ensure that the Qt plugins are found:

    \list

    \li \l{qt-conf.html}{Using \c qt.conf}. This is the recommended
    approach as it provides the most flexibility.

    \li Using QApplication::addLibraryPath() or
    QApplication::setLibraryPaths().

    \li Using a third party installation utility to change the
    hard-coded paths in the QtCore library.

    \endlist

    The \l{How to Create Qt Plugins} document outlines the issues you
    need to pay attention to when building and deploying plugins for
    Qt applications.

    \section2 Additional Libraries

    You can check which libraries your application is linking against
    by using \c otool. Run this with the application path as an argument:

    \snippet snippets/code/doc_src_deployment.qdoc 50

    Unlike the deployment processes on \l {Deploying an Application on
    X11 Platforms}{X11} and \l {Deploying an Application on
    Windows}{Windows}, compiler-specific libraries rarely have to
    be redistributed with your application. But there are several ways to
    deploy applications, as Qt can be configured, built, and installed in
    several ways on Mac OS X. Typically your goals help determine how you
    are going to deploy the application. The last sections describe a few
    things that you must be aware of while deploying your application.

    \section2 Mac OS X Version Dependencies

    Qt 5 applications can be built and deployed on Mac OS X 10.6
    (Snow Leopard) and higher. This is achieved using \e{weak linking}. In
    \e{weak linking}, Qt tests whether a function added in a newer
    version of Mac OS X is available on the computer it is running
    on. This allows Qt to use newer features when it runs on a newer
    version of OS X, while remaining compatible on the older versions.

    For more information about cross development issues on Mac OS X,
    see \l
    {https://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/cross_development/Introduction/Introduction.html}{Apple's Developer Website}.

    The linker is set to be compatible with all OS X versions,
    so you must change the \c MACOSX_DEPLOYMENT_TARGET environment
    variable to get \e{weak linking} to work for your application. You
    can add the following:

    \snippet snippets/code/doc_src_deployment.pro 51

    to your .pro file, and qmake will take care of this for you.

    For more information about C++ runtime environment, see \l
    {https://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html}{Apple's Developer Website}

    \section1 The Mac Deployment Tool
    \target macdeploy
    The Mac deployment tool can be found in QTDIR/bin/macdeployqt. It is
    designed to automate the process of creating a deployable
    application bundle that contains the Qt libraries as private
    frameworks.

    The mac deployment tool also deploys the Qt plugins, according
    to the following rules:
    \list
    \li Debug versions of the plugins are not deployed.
    \li The designer plugins are not deployed.
    \li The Image format plugins are always deployed.
    \li SQL driver plugins are deployed if the application uses the QtSql module.
    \li Script plugins are deployed if the application uses the QtScript module.
    \li The svg icon plugin is deployed if the application uses the QtSvg module.
    \li The accessibility plugin is always deployed.
    \endlist

    \note If you want a 3rd party library to be included in your
    application bundle, you must copy the library into the
    bundle manually, after the bundle is created.

    \c macdeployqt supports the following options:
    \list
    \li -no-plugins: Skip plugin deployment
    \li -dmg       : Create a .dmg disk image
    \li -no-strip  : Don't run 'strip' on the binaries
    \endlist
*/
